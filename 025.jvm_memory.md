# JVM 的内存区域划分
1. 程序计数器 (Program Counter Register) 每个 thread 都有自己的程序计数器 (PC). 程序计数器存储线程正在执行的 java 方法的 JVM 指令地址。
2. Java 虚拟机栈 (JVM Stack) 每个thead 有自己的 JVM stack, 其内部保存一个个栈帧(Stack Frame), 对应一次次的 java 方法调用。栈帧中保存局部变量表，操作数栈，动态链接等。
3. Heap (堆)， java 内存管理核心区域。用来放置 java 对象。几乎所有创建的 java 对象实例都直接分配在堆上。堆被所有 thread 共享。 jvm 启动时指定的 Xmx 用来指定最大堆空间。堆空间被GC 进一步细分：新生代，老年代。
4. 方法区 (Method Area) 线程共享的内存区域，用于存储元 (meta) 数据，例如类结构信息，对应的运行时常量池，字段，方法代码等。
5. 本地方法栈。

# OOM
OutOfMemoryError, JVM 内存不够用了。没有空闲内存，并且垃圾收集器也无法提供更多内存。在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出内存空间。

* 除了程序计数器，其他区域都有可能抛出 OutOfMemoryError
    * 堆内存不足 (heap) 抛出 OOM
    * JVM Stack 和本地方法栈， 不断进行递归调用会导致 StackOverFlowError, 如果 JVM 试图扩展栈空间会抛出 OutOfMemoryError
    * 老版本的 Oracle JDK , 永久代大小有限，JVM 回收非常不积极。 `OutOfMemoryError:PermGen space`
    * 元数据区的引入，方法区内存不再那么窘迫。异常信息`OutOfMemoryError: Metaspace`

# 如何诊断 JVM 堆内堆外内存使用
了解 jvm 内存的方法很多
* 可以使用综合性图形化工具 JConsole, VisualVM. 这些工具比价直观，直接连接到 java 进程，在图形化界面掌握内存的使用情况。

JConsole 为例，其内存页显示常见的 `堆内存` 和 `各种堆外部分` 的使用情况。

* 使用命令行工具进行运行时查询， jstat 和 jmap 提供了一些选项，可以查看堆，方法区的使用数据。
* 使用 jmap 生成 heap dump 文件，使用 jhat 或 eclipse mat 等 heap dump 分析工具。


# 堆内部结构
1. 新生代 (Eden + survivor space(s0, s1) + virtual) `Young Generation`, 新生代是大部分对象创建和销毁的区域。大部分对象的生命周期都很短暂。Eden 区域，作为对象初始分配的区域，两个 survivor 区域 (s0, s1), 有时也叫 from, to 区域。用来放置从 minor gc 保留下来的对象。
    * jvm 随意选一个 survivor 区作为 to 区，会在 GC 过程中进行域间拷贝，也就是将 Eden 中存活的对象和 from 区域的对象拷贝到 to 区域，这种设计为了放置内存碎片化，并进一步清理无用对象。
    * 从内存模型的角度 ， Eden 区域或进一步划分。 Hotspot JVM 有个概念叫 Thread Local Allocation Buffer (TLAB). jvm 为每个线程提供一个私有缓存区域。避免多线程操作同一地址，加锁影响分配速度。 start, end 起止地址， top(指针)表示分配到哪里了。
2. 老年代 ,放置长生命周期对象，通常是从 survivor 区域拷贝过来的对象。
3. 永久代， 早期 jvm 的实现方式，存储元数据，常量池。 Jdk8 后就不存在永久代了。

最大堆体积 `-Xmx value`

最小堆体积 `-Xms value`

老年代和新生代的比例 `-XX:NewRatio=value`, 默认是 2， 老年代是新生代的 2 倍。

Eden 和 survivor 的比例， `-XX:SurvivorRatio=value`